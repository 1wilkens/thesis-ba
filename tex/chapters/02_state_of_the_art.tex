\chapter{State of the art}
\label{chap:State_of_the_art}

\textit{%
In diesem Kapitel ...
}
\bigskip

- state of C and Fortran (section name?)

- technological advancements in low level languages
    - static analysis
    - ..
    -> But no real adaption possible, because language level support is missing



// Candidates here for now might need another chapter for those

\section{Candidates}
\label{sec:Candidates}

This section aims to provide a rough overview of possible candidates to be used in high performance computing. Each language is introduced and categorized and at the end a quick comparison shows which are evaluated further in the thesis.

\subsection*{Python}
\label{ssec:Candidates.Python}

Most of the people programming for high performance computers are scientist of research fields other than computer science. With this in mind Python seems a logical programming language to use. It is an interpreted general-purpose programming language which aims to be very expressive and flexible. Compared with C and Fortran which sacrifice feature richness for performance, Python's huge standard library combined with the automatic memory management offers a low border of entry and quick prototyping capabilities. \\
%  wording
As a matter of fact many introductory computer science courses at universities in the United States recently switched from Java to Python as their first programing language. \cite{GUO14} This allows the students to focus on core concepts and algorithms instead of boilerplate code.
\\ \\
// code example (hello world?)
\\ \\
In addition to the very extensive standard library the Python community has created a lot of open source projects aiming to support especially scientific applications. There is NumPy\footnote{www.numpy.org} which offers efficient implementations for multidimensional arrays and common numeric algorithms like Fourier transforms or MPI4Py\footnote{www.mpi4py.scipy.org}, an MPI abstraction layer able to interface with various backends like OpenMPI or MPICH. Especially the existance of the latter shows the ongoing attempts to use Python in a cluster environment and there have been successful examples of scientific high-performance applications ( //need ref ).
\\ \\
Unfortunately dynamic typing and automatic memory management come at a rather high price. The speed of raw numeric algorithms written in plain Python is almost always orders of magnitude slower than implementations in C or Fortran. As a consequence nearly all of the mentioned libraries implement the critical routines in C and focus in optmizing the interop (// wording) experience. This often means one needs to make tradeoffs between idiomatic Python - which might not be transferable to the foreign language - and maximum performance.

- python losing expressiveness (find alternatives) -> python losing justification for HPC
- alternative implementations (medusa! and others)

\subsection*{Erlang}
\label{ssec:Candidates.Erlang}
Erlang is a relatively niche programming language originally designed for the use in telephony applications. It features a high focus on concurrency and a garbage collector which is enabled through the execution inside the BEAM virtual machine.

- brief history?

- code example (not hello world rather show message passing)

- Upsides
    - Great concurrency
    - Message passing is default (no locks)
    - Hot swap?
- Downsides
    - Bad interfacing to other languages
    - Weird syntax
    - Limited (community/support?)


\subsection*{Go}
\label{ssec:Candidates.Go}
Go is a relatively new programming language which focusses on simplicity and clarity while not sacrificing too much performance.
\\ \\
- brief history

- hello world or something similar
\\ \\
Go was chosen as a candidate because it provides simple concurrency primitives as part of the language (goroutines) while having a C-like syntax and beeing resonably performant. It also compiles to native code without external dependencies which makes it usable on cluster computers which might not have required libraries installed.

- Prediction implementation
    - A bit of syntax weirdness
    - Relatively quick PoC with decent concurrency aspects
    - Some fixing/optimization afterwards regarding common concurrency errors
    -> More time spent after initial PoC but less than in C


\subsection*{Rust}
\label{ssec:Candidates.Rust}
The last candidate discussed in this chapter is Rust. Developed in the open but strongly backed by Mozilla Rust aims to directly compete with C and C++ as a systems language. It focuses on memory safety which is checked and verified at compile without (or with minimal) impact on runtime performance.

- Key features

- Up/Downside

- Prediction Implementation
    - Moderatly quick PoC without concurrency at first
    - Nearly only otimization afterwards since compilation secures memory safety
    -> More time spent before initial PoC than after


\subsection*{Comparison}
\label{ssec:Candidates.Comparison}

% will probably not fit
\begin{tabular}{llll}
    \toprule
    % Header
        & Python
        & Erlang
        & Go
        & Rust \\
    \midrule

    Execution model
        & interpreted
        & compiled to bytecode
        & compiled to native code
        & compiled to native code \\

    Advantages
        & low barrier of entry
        & builtin (lockfree) concurrency support
        & adv go
        & adv rust \\

    Disadvantages
        & speed
        & obscure syntax
        & mandatory runtime
        & disadv rust \\

    Relative speed
        & slow to average
        & average to fast
        & speed go
        & speed rust \\
    \bottomrule
\end{tabular}
