\chapter{State of the art}
\label{chap:State_of_the_art}

\abstract{%
This chapter describes the current state of the art in high-performance computing. The dominance of Fortran and C is explained in~\autoref{sec:State_of_the_art::Weaknesses_C_Fortran} and after that all considered language candidates are introduced and characterized.
}

- state of C and Fortran (section name?)

- technological advancements in low level languages
    - static analysis
    - ..
    -> But no real adaption possible, because language level support is missing (already included in introduction)

\section{Weaknesses of C and Fortran} % change name?
\label{sec:State_of_the_art::Weaknesses}

As stated in~\autoref{sec:Introduction::Motivation} high-performance computing is largely dominated by C and Fortran. To understand why a new language is needed it is essential to understand the shortcomings of these programming veterans. (//language?)

\subsection*{}

// Candidates here for now might need another chapter for those
\section{Candidates}
\label{sec:State_of_the_art::Candidates}

This section aims to provide a rough overview of possible candidates that were considered for further evaluation in this thesis.

\subsection*{Python}
\label{subsec:State_of_the_art::Candidates::Python}

Python is an interpreted general-purpose programming language which aims to be very expressive and flexible. Compared with C and Fortran which sacrifice feature richness for performance, Python's huge standard library combined with the automatic memory management offers a low border of entry and quick prototyping capabilities.

%  wording
As a matter of fact many introductory computer science courses at universities in the United States recently switched from Java to Python as their first programing language.~\cite{GUO14, intro_py} This allows the students to focus on core concepts and algorithms instead of boilerplate code.
\\
\lstinputlisting[caption={FizzBuzz in Pyhon 3.4}, label={lst:example.py}, style=python]{code/example.py}

In addition to the very extensive standard library the Python community has created a lot of open source projects aiming to support especially scientific applications. There is NumPy~\footnote{\url{http://www.numpy.org}} which offers efficient implementations for multidimensional arrays and common numeric algorithms like Fourier transforms or MPI4Py~\footnote{\url{http://www.mpi4py.scipy.org}}, an MPI abstraction layer able to interface with various backends like OpenMPI or MPICH. Especially the existance of the latter shows the ongoing attempts to use Python in a cluster environment and there have been successful examples of scientific high-performance applications using these libraries( //need ref ).

Unfortunately dynamic typing and automatic memory management come at a rather high price. The speed of raw numeric algorithms written in plain Python is almost always orders of magnitude slower than implementations in C or Fortran. As a consequence nearly all of the mentioned libraries implement the critical routines in C and focus in optimizing the interop (// wording) experience. This often means one needs to make tradeoffs between idiomatic Python - which might not be transferable to the foreign language - and maximum performance. As a result performance critical python code often looks like it's equivalent written in a statically typed language and the more terseness Python loses because of this the less desireable it becomes to use in high-performance computing since one could just fall back to C for a similar experience.

In conclusion Python was not chosen to be further evaluated because of the mentioned lack of performance (in pure Python). This might change with some new implementations emerging recently though. Most of the problems discussed here are present in all stable Python implementations today (most notably \textit{Cython} and \textit{PyPy}) but new projects aim to improve the execution speed in various ways. \textit{Medusa} compiles Python code to Google's Dart to make use of the underlying virtual machine. Although these ventures are still in early phases of development, first early benchmarks promise drastic performance improvements. Once Python can achieve similar execution speed to native code (by a maximum of one order of magnitude) it will become a serious competitor in the high performance area.

\subsection*{Erlang}
\label{subsec:State_of_the_art::Candidates::Erlang}
Erlang is a relatively niche programming language originally designed for the use in telephony applications. It features a high focus on concurrency and a garbage collector which is enabled through the execution inside the BEAM virtual machine. Today it is most often used in soft real-time computing~\footnote{see \url{https://en.wikipedia.org/wiki/Real-time_computing}} because of it's error tolerance, hot code reload capabilities and lock-free concurrency support.

- brief history?

- code example (not hello world rather show message passing)

- Upsides
    - Great concurrency
    - Message passing is default (no locks)
    - Hot swap?
- Downsides
    - Bad interfacing to other languages
    - Weird syntax
    - Limited (community/support?)


\subsection*{Go}
\label{subsec:State_of_the_art::Candidates::Go}
Go is a relatively new programming language which focusses on simplicity and clarity while not sacrificing too much performance. Initially developed by Google it aims to ``make it easy to build simple, reliable and efficient software'' (//cite). It is statically typed, offers a garbage collector, basic type inference and a large standard library. Go's syntax is loosely inspired by C but made some major changes like removing the mandatory semicolon at the end of commands and changing the order of types and identifiers. It was chosen as a candidate because it provides simple concurrency primitives as part of the language (so called \textit{goroutines}) while having a familiar syntax and beeing reasonably performant.~\cite{intro_go} It also compiles to native code without external dependencies which makes it usable on cluster computers without many additional libraries installed.

The chosen code example demonstrated two key features which are essential to concurrent programming in Go - the already mentioned goroutines as well as channels used for synchronization purposes. These provide a way to communicate with goroutines via message passing.

\lstinputlisting[caption={Go concurrency example}, label={lst:example.go}, style=go]{code/example.go}

Initially developed for server scenarios Go has seen production use in many different areas. At Google it is used for various internal project such as the download service ``dl.google.com'' which has been completely rewritten from C++ to Go in 2012. The new version can handle more bandwith while using less memory. It is also noteable that the Go codebase is about half the size of the legacy application with increases test coverage.~\cite{go_dl_google}

All these statistics show the core focus of the language // simplicity and avoidance of boilerplate

- brief history

- Prediction implementation
    - A bit of syntax weirdness
    - Relatively quick PoC with decent concurrency aspects
    - Some fixing/optimization afterwards regarding common concurrency errors
    -> More time spent after initial PoC but less than in C


\subsection*{Rust}
\label{subsec:State_of_the_art::Candidates::Rust}
The last candidate discussed in this chapter is Rust. Developed in the open but strongly backed by Mozilla Rust aims to directly compete with C and C++ as a systems language. It focuses on memory safety which is checked and verified at compile without (or with minimal) impact on runtime performance. Rust compiles to native code using a custom fork of the popular LLVM\footnote{\url{http://www.llvm.org}} as backend and is compatible to common tools like the gdb\footnote{\url{http://www.gnu.org/software/gdb/}} debugger which makes integration into existing workflows a bit easier.

Out of the here discussed languages Rust is closest to C while attempting to fix common mistakes made possible by it's loose standard allowing undefined behaviour. (//wording?) Memory safety is enforced through a very sophisticated model of ownership. It is based on common concepts which are already employed on concurrent applications. The basic rule is that every piece of allocated memory is \textit{owned} by \textit{one} entity in the program (typically a variable) and only the owner can change the contents of that memory. To allow more complex algorithms values can be borrowed

- Key features

- Up/Downside

- Prediction Implementation
    - Moderatly quick PoC without concurrency at first
    - Nearly only otimization afterwards since compilation secures memory safety
    -> More time spent before initial PoC than after


\subsection*{Comparison}
\label{subsec:State_of_the_art::Candidates::Comparison}

% will probably not fit
\begin{tabular}{llll}
    \toprule
    % Header
        & Python
        & Erlang
        & Go
        & Rust \\
    \midrule

    Execution model
        & interpreted
        & compiled to bytecode
        & compiled to native code
        & compiled to native code \\

    Advantages
        & low barrier of entry
        & builtin (lockfree) concurrency support
        & adv go
        & adv rust \\

    Disadvantages
        & speed
        & obscure syntax
        & mandatory runtime
        & disadv rust \\

    Relative speed
        & slow to average
        & average to fast
        & speed go
        & speed rust \\
    \bottomrule
\end{tabular}
