\chapter{State of the art}
\label{chap:State_of_the_art}

\abstract{%
This chapter describes the current state of the art in high-performance computing. The dominance of Fortran and C is explained in~\autoref{sec:State_of_the_art::Weaknesses_C_Fortran} and after that all considered language candidates are introduced and characterized.
}

- state of C and Fortran (section name?)

- technological advancements in low level languages
    - static analysis
    - ..
    -> But no real adaption possible, because language level support is missing (already included in introduction)

\section{Weaknesses of C and Fortran} % change name?
\label{sec:State_of_the_art::Weaknesses}

As stated in~\autoref{sec:Introduction::Motivation} high-performance computing is largely dominated by C and Fortran. To understand why a new language is needed it is essential to understand the shortcomings of these programming veterans. (//language?)

\subsection*{}

// Candidates here for now might need another chapter for those
\section{Candidates}
\label{sec:State_of_the_art::Candidates}

This section aims to provide a rough overview of possible candidates that were considered for further evaluation in this thesis.

\subsection*{Python}
\label{subsec:State_of_the_art::Candidates::Python}

Python is an interpreted general-purpose programming language which aims to be very expressive and flexible. Compared with C and Fortran which sacrifice feature richness for performance, Python's huge standard library combined with the automatic memory management offers a low border of entry and quick prototyping capabilities.

%  wording
As a matter of fact many introductory computer science courses at universities in the United States recently switched from Java to Python as their first programing language.~\cite{GUO14, intro_py} This allows the students to focus on core concepts and algorithms instead of boilerplate code.
\\
\lstinputlisting[caption={FizzBuzz in Pyhon 3.4}, label={lst:example.py}, style=python]{code/example.py}

In addition to the very extensive standard library the Python community has created a lot of open source projects aiming to support especially scientific applications. There is NumPy~\footnote{\url{http://www.numpy.org}} which offers efficient implementations for multidimensional arrays and common numeric algorithms like Fourier transforms or MPI4Py~\footnote{\url{http://www.mpi4py.scipy.org}}, an MPI abstraction layer able to interface with various backends like OpenMPI or MPICH. Especially the existance of the latter shows the ongoing attempts to use Python in a cluster environment and there have been successful examples of scientific high-performance applications using these libraries( //need ref ).

Unfortunately dynamic typing and automatic memory management come at a rather high price. The speed of raw numeric algorithms written in plain Python is almost always orders of magnitude slower than implementations in C or Fortran. As a consequence nearly all of the mentioned libraries implement the critical routines in C and focus in optimizing the interop (// wording) experience. This often means one needs to make tradeoffs between idiomatic Python - which might not be transferable to the foreign language - and maximum performance. As a result performance critical python code often looks like it's equivalent written in a statically typed language and the more terseness Python loses because of this the less desireable it becomes to use in high-performance computing since one could just fall back to C for a similar experience.

In conclusion Python was not chosen to be further evaluated because of the mentioned lack of performance (in pure Python). This might change with some new implementations emerging recently though. Most of the problems discussed here are present in all stable Python implementations today (most notably \textit{Cython} and \textit{PyPy}) but new projects aim to improve the execution speed in various ways. \textit{Medusa} compiles Python code to Google's Dart to make use of the underlying virtual machine. Although these ventures are still in early phases of development, first early benchmarks promise drastic performance improvements. Once Python can achieve similar execution speed to native code (by a maximum of one order of magnitude) it will become a serious competitor in the high performance area.

\subsection*{Erlang}
\label{subsec:State_of_the_art::Candidates::Erlang}
Erlang is a relatively niche programming language originally designed for the use in telephony applications. It features a high focus on concurrency and a garbage collector which is enabled through the execution inside the BEAM virtual machine. Today it is most often used in soft real-time computing~\footnote{see \url{https://en.wikipedia.org/wiki/Real-time_computing}} because of it's error tolerance, hot code reload capabilities and lock-free concurrency support.

- brief history?

- code example (not hello world rather show message passing)

- Upsides
    - Great concurrency
    - Message passing is default (no locks)
    - Hot swap?
- Downsides
    - Bad interfacing to other languages
    - Weird syntax
    - Limited (community/support?)


\subsection*{Go}
\label{subsec:State_of_the_art::Candidates::Go}
Go is a relatively new programming language which focusses on simplicity and clarity while not sacrificing too much performance. Initially developed by Google it aims to ``make it easy to build simple, reliable and efficient software'' (//cite). It is statically typed, offers a garbage collector, basic type inference and a large standard library. Go's syntax is loosely inspired by C but made some major changes like removing the mandatory semicolon at the end of commands and changing the order of types and identifiers. It was chosen as a candidate because it provides simple concurrency primitives as part of the language (so called \textit{goroutines}) while having a familiar syntax and beeing reasonably performant.~\cite{intro_go} It also compiles to native code without external dependencies which makes it usable on cluster computers without many additional libraries installed.

The chosen code example demonstrates two key features which are essential to concurrent programming in Go - the already mentioned goroutines as well as channels used for synchronization purposes. These provide a way to communicate with running goroutines via message passing.
\\
\lstinputlisting[caption={Go concurrency example}, label={lst:example.go}, style=go]{code/example.go}

Initially developed for server scenarios Go has seen production use in many different areas. At Google it is used for various internal project such as the download service ``dl.google.com'' which has been completely rewritten from C++ to Go in 2012. The new version can handle more bandwith while using less memory. It is also noteable that the Go codebase is about half the size of the legacy application with increases test coverage and performance.~\cite{go_dl_google}

All these statistics show the core focus of the language // simplicity and avoidance of boilerplate

- Prediction implementation
    - A bit of syntax weirdness
    - Relatively quick PoC with decent concurrency aspects
    - Some fixing/optimization afterwards regarding common concurrency errors
    -> More time spent after initial PoC but less than in C


\subsection*{Rust}
\label{subsec:State_of_the_art::Candidates::Rust}
The last candidate discussed in this chapter is Rust. Developed in the open but strongly backed by Mozilla Rust aims to directly compete with C and C++ as a systems language. It focuses on memory safety which is checked and verified at compile without (or with minimal) impact on runtime performance. Rust compiles to native code using a custom fork of the popular LLVM\footnote{\url{http://www.llvm.org}} as backend and is compatible to common tools like \textbf{The GNU Project Debugger} (\textit{gdb})~\footnote{\url{http://www.gnu.org/software/gdb/}} which makes integration into existing workflows a bit easier.

Out of the here discussed languages Rust is closest to C while attempting to fix common mistakes made possible by it's loose standard allowing undefined behaviour. (//wording?) Memory safety is enforced through a very sophisticated model of ownership. It is based on common concepts which are already employed on concurrent applications but integrates them on a langage level and enforces them at compile time. The basic rule is that every resource in an applications (for example allocated memory or file handles) has exactly one \textit{owner} at a time. To share access to a resource one can you use references denoted by a '\&'. These can been seen as pointers in C with the additional caveat that they are readonly. To gain mutable access to a resource one must acquire a mutable reference via '\&mut'. To ensure memory safety a special part of the compiler, the \textit{borrow checker}, validates that there is never more than one mutable reference to the same resource. This effectively prevents mutable aliasing which in turn rules out a whole class of errors like iterator invalidation. It is important to remember that these checks are a ``zero cost abstraction'' which means they do not have any runtime overhead but enforce additional security at compile time through static analysis.

Another core aspect of Rust are \textit{lifetimes}. As many other programming languages Rust has scopes introduced by blocks for example function and loop bodies or arbitrary scopes opened and closed by curly braces. Combined with the ownership system the compiler can exactly determine when the owner of a resource gets out of scope and call the appropiate destructor (called \lstinline$drop$ in Rust). This technique is called ``Resource acquisition is initialization''.~\cite[p. 389]{evolution_c++} Unlike in C++ it is not limited to stack allocated objects since the compiler can rely on the ownership system to verify that no references to a resource are left when its owner gets out of scope. It is therefore safe to drop.
\\
\lstinputlisting[caption={Rust example}, lable={lst:example.rs}, style=rust]{code/example.rs}

Although Rust focusses on performance and safety it also adopted some functional concepts like \textit{pattern matching} and the \lstinline$Option$ type. Combined with \lstinline$range$ expressions and macros which operate on syntax level codong in Rust often feels like in a scripting language which is just very performant. This was also the main reason it was chosen to be further evaluated. Rust focusses on safety while not sacrificing any performnce in the process. Most of the checks happen at compile time making the resulting binary often close or on par with equivalent C programs. It also has the advantage of beeing still in development~\footnote{current version beeing \textbf{1.0.0-beta-1} at the time of this writing} so concepts which did not work out can be quickly changed or completely dropped.
But Rust's immatureness is also its greatest weakness. The

- mention cargo

- Prediction Implementation
    - Moderatly quick PoC without concurrency at first
    - Nearly only otimization afterwards since compilation secures memory safety
    -> More time spent before initial PoC than after


\subsection*{Comparison}
\label{subsec:State_of_the_art::Candidates::Comparison}

% will probably not fit
\begin{tabular}{llll}
    \toprule
    % Header
        & Python
        & Erlang
        & Go
        & Rust \\
    \midrule

    Execution model
        & interpreted
        & compiled to bytecode
        & compiled to native code
        & compiled to native code \\

    Advantagesree) concurrency support
        & adv go
        & adv rust \\

    Disadvantages
        & speed
        & obscure syntax
        & mandatory runtime
        & disadv rust \\

    Relative speed
        & slow to average
        & average to fast
        & speed go
        & speed rust \\
    \bottomrule
\end{tabular}
