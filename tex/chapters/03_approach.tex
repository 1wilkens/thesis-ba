\chapter{Approach}
\label{chap:Approach}

\abstract{The first section of the third chapter describes the existing application the evaluation is based on.  In addition the implementation process is illustrated and methods the comparison of languages is based on are introduced.}

\section{Overview: Streets4MPI}
\label{sec:Approach::Overview}

As stated in~\autoref{sec:Introduction::Goals} the language evaluation is based on a reimplementation of an existing parallel program originally written in Python. The application in question is \textit{streets4MPI} - a traffic simulation using OpenStreetMap files as input and calculating shortest routes via Dijkstra's algorithm. Streets4MPI was implemented in scope of the module ``Parallel Programming Project'' in Spring 2012. It was written by Julian Fietkau and Joachim Nitschke and makes heavy use of the various libraries of the Python ecosystem.

//TODO: more description

The original project contained the main simulation as well as a visualization script.~\cite[p.~3]{streets_report} For the purpose of this thesis the visualization was omitted and the evaluation is only based on software quality metrics as well as the result's correctness. //TODO: really cite page?

\section{Differences to the base implementation}
\label{sec:Approach::Differences}

Although the evaluated implementations are based on the original Streets4MPI, there are some key differences (mainly to reduce complexity). This section gives a brief overview over the most important aspects that have been changed and describes both the original application as well as the the redeveloped version.

In the remaining part of the thesis the different implementations will be referenced quite frequently. For brevity each application will be called by its name ``streets4<language>'' for example ``streets4go''. //wording..

\subsection*{Input format}
\label{subsec:Approach::Differences::Input}

The original implementation used the somewhat dated OpenStreetMap XML format~\footnote{\url{http://wiki.openstreetmap.org/wiki/OSM_XML}} as input which is parsed by \textit{imposm.parser}~\footnote{\url{http://imposm.org/docs/imposm.parser/latest/}}. Streets4MPI then builds a directed graph via the \textit{python-graph}~\footnote{\url{https://code.google.com/p/python-graph/}} library to base the simulation on.\cite{streets_report}

The reimplementations require the input to be in ``.osm.pbf'' format. This newer version of the OpenStreetMap format is based on Google's \textit{Protocol Buffers}~\footnote{\url{https://developers.google.com/protocol-buffers/}} and is superior to the XML variant in both size and speed~\cite{osm_wiki_pbf}. It also simplifies multilanguage development because the code performing the actual parsing is auto generated from a language independent description file and there are protobuf backends for C, Rust and Go which can perform that generation.

\subsection*{Simulation}
\label{subsec:Approach::Differences::Simulation}

The simulation in streets4MPI is based on randomly generated trips in the directed graph that was build from the input. For these trips the shortest path is calculated by Dijkstra's algorithm (//cite). To avoid oscillation a random factor called ``jam tolerance'' is introduced. Then after some time has passed in the simulation existing streets get expanded or shut down depending on the usage. The reimplementations to compare also perform trip based simulation but to without the added randomness and street modification. Also a variant of Diskstra's algorithm was implemented in all three languages in a benchmarkable way so it can be compared separately. The concept is based on the \textsc{Dijkstra-NoDec} algorithm as seen in~\cite[p. 16]{dijkstra_utcs} This is done to rule out possible errors in the complete streets4x implementations and be able to directly compare the algorithmic part of the application.

\subsection*{Concurrency}
\label{subsec:Approach::Differences::Concurrency}

The base application parallelizes its calculations on multiple processes that communicate via message passing. This is achieved with the aforementioned MPI4Py library which delegates to a native MPI implementation installed on the system. If no supported implementation is found it falls back to a pure Python solution although the native one should be preferred for maximum performance.

Although Rust as well as Go can integrate decently with existing native code, the reimplementations will be limited to shared memory parallelization on threads. This was mostly decided to evaluate and compare the language inherent concurrency constructs rather than the quality of the forrign funtion interface. To achieve fair comparability \textit{streets4c} will use OpenMP~\footnote{\url{http://www.openmp.org}} as it is the de facto standard for simple thread parallelization in C.

\section{Implementation process}
\label{sec:Approach::Implementation}

The implementation process was performed iteratively. Certain milestones were defined and implemented in all three languages. The process only proceeded to the next phase when the previous milestone was reached in all applications. This approach was chosen to allow for a fair comparison of the different stages of development. If the implementations would have been developed one after another to completion, this might have introduced a certain bias to the evaluation because of possible knowledge about the problem aquired in a previous language translating to faster results in the next one.

For each stage various characteristics were captured and compared to highlight the languages' features and performance in the varaious areas

\setcounter{subsection}{-1}
\subsection{[Setting up the project]}
\label{subsec:Approach::Implementation::Setup}

The first stage of development was to create project skeletons and infrastructure for the future development. The milestone was to have a working environment in place where the sample application could be build and executed. While this is certainly not the most important or even interesting part it did show the differences in comfort between the various toolchains.

\subsection{Counting nodes, ways and relations in an .osm.pbf file}
\label{subsec:Approach::Implementation::Counting}

The first real milestone was to read a .osm.pbf file and count all nodes, ways and relations in it. This was done to get familiar with the required libraries and the file format in general. The time recorded began from the initial project created in stage 0 and finished after the milestone was reached. As this is the most input and output intensive stage it already showed some key differences between the candidates both in speed as well as memory consumption.

\subsection{Building a basic graph representation for the simulation}
\label{subsec:Approach::Implementation::Graph_Representation}

The next goal was to conceptionally build the graph and related structures the simulation would later operate on. This involved thinking about the relation between edges and nodes as well as the choice of various containers to store the objects efficiently while also keeping access simple. This milestone tested the language's standard libraries and ability to express functions in a compact way (lambda..)

\subsection{Verifying the representation and algorithm}
\label{subsec:Approach::Implementation::Verifiying}

After the base structure to represent graphs and calculate shortest paths is in place it was time to validate the implementations. Unfortunately the OSM data used in the first phase~\ref{subsec:Approach::Implementation::Counting} contained too much nodes and ways to be able to efficiently verify any computed results. Therefore a small example graph was manually populated and fed to the algorithm. However unlike the final application the start and end nodes were fixed to allow for comparable results.
