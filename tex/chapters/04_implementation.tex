\chapter{Implementation}
\label{ch:Implementation}

\abstract{This chapter describes the implementation process for all three compared languages. It is divided in sections based on the development milestones defined in the previous chapter~\ref{sec:Approach::Implementation}.
}

\setcounter{section}{-1}
\section{Project setup}
\label{sec:Implementation::Setup}

As all applications written for this thesis have been developed on Linux the setup instructions are for this operating system. They \textbf{should} work on *nix as well but there is no definite guarantee this is the case. Also each section assumes the toolchains for the various languages are installed as this is largely different based on what operating system and on Linux which distribution is used. It is therefore not covered in this thesis.

\subsection{C}
\label{subsec:Implementation::Setup::C}

//TODO: Add footnotes/links

The buildtool for streets4C is GNU \textit{make} with a simple handcrafted \shinline{Makefile}. It was chosen to strike a balance between full blown build systems like \textit{Autotools} or \textit{CMake} and manual compilation. The setup steps required for this configuration are relatively straight forward and listed below.
\\
\lstinputlisting[caption={Project setup: streets4C}, label={lst:setup_c.sh}, style=shell]{code/setup_c}

After creatig a new directory for the application a \shinline{Makefile} and a sourcefile are created. \shinline{main.c} contains just a bare bones main method while the \shinline{Makefile} uses basic rules to compile an executable named streets4c with various optimization flags.

All in all the setup in C is quite painless although manual. The only caveat are Makefiles. They may be simple for small projects without real dependencies but as soon as different source and object files are involved in the compilation process they can get quite confusing. At that point the mentioned build systems might prove their worth in generating the \shinline{Makefile}(s) from other configuration files.


\subsection{Go}
\label{subsec:Implementation::Setup::Go}

//TODO: Add footnotes/links

For Go the choice of buildtool is nonexistent. The language provides the \shinline{go} executable which is responsible for nearly the complete development cycle. It can compile your code, install arbitrary Go packages from various sources, run tests and format code just to name the most common features.

This makes Go (the language) extremely convenient since everything you want to do is probably one commandline away. For example to get a dependency one would invoke the tool like so:
\mdinline{go get github.com/petar/GoLLRB/llrb}
\\
This will download the package in source form which can then be imported in any project on that machine via its fully qualified package name.

To achieve this convenience the \shinline{go} tool requires some setup work before it can be used for the first time. Because of this this section contains two setup examples.
\\
\lstinputlisting[caption={Project setup: streets4Go}, label={lst:setup_go.sh}, style=shell]{code/setup_go}

Listing \ref{lst:setup_go.sh} describes the steps that were taken to create the streets4go project inside the thesis' repository. It is pretty similiar to the C version. A directory gets creates then a source file containing a \shinline{main} function is created which can be build and run with a single command.

One thing to remind here is the fact, that this code does not live inside a globally set drectory called \shinline{GOPATH}. To be able to download packages only once \shinline{go} assumes an environment variable called \shinline{GOPATH} to be set to a directory which it has full control over. This directory contains all source files as well a the compiled binaries all stored through a consistent naming scheme. Normally it is assumed that all Go project live inside their own subdirectories of the \shinline{GOPATH} but it is possible to avoid this at the cost of some convenience.

The project that was created through the commands of listing \ref{lst:setup_go.sh} for example cannot be installed to the system by running \mdinline{go install} since it does not reside in the correct folder instead one has to copy the compiled binary to a directory in \shinline{PATH} manually.

The next listing shows a more realistic workflow for creating a new Go project from scratch without any prior setup required. It assumes one starts in the directory that should be set as \shinline{GOPATH} and assumes \url{www.github.com} as code host which in reality just determines the package name. It is also important to add the export shown in the first line to any inititalization file of your shell or operating system to ensure it always beeing available.
\\
\lstinputlisting[caption={Full setup for new Go projects}, label={lst:setup_go_full.sh}, style=shell]{code/setup_go_full}


\subsection{Rust}
\label{subsec:Implementation::Setup::Rust}

//TODO: Add footnotes/links

Similar to Go also Rust provides its own build system. As mentioned in the \hyperref[subsec:State_of_the_art::Candidates::Rust]{candidate introduction} Rust installs its own package manager \textit{cargo}. It functions as build system and is also capable of creating new projects. This shortens the setup process considerably as observable in the next listing.
\\
\lstinputlisting[caption={Project setup: streets4Rust}, label={lst:setup_rust.sh}, style=shell]{code/setup_rust}

With the \shinline{new} subcommand a new project gets created. The \shinline{-{}-bin} flag tells \shinline{cargo} to create an executable project instead of a library which is the default.
Thanks to the one command all the initial files and directories are created with one single command. This includes:
\begin{itemize}
    \item{the project directory itself (named like the given project name)}
    \item{a \shinline{src} directory for source files}
    \item{a \shinline{target} directory for build results}
    \item{a required manifest file named \shinline{Cargo.toml} including the given project name}
    \item{a sample file inside \shinline{src} which is either called \shinline{main.rs} for binaries or \shinline{lib.rs} for libraries containing some sample code
    \item{and optionally an empty initialized version control repository (\shinline{git} or \shinline{mercurial} if the corresponding command line option has been passed)}
\end{itemize}
The resulting application is already runnable via \mdinline{cargo run}\footnote{which is executable anywhere inside the project directory} and produces some output in \shinline{stdout}. This process is extremely convenient and error proof since \shinline{cargo} validates all input before executing any task. The \shninline{man} pages and help texts are quite thin at the moment but as with everything in the Rust world \shinline{cargo} is still beeing developed.

The overall greated advantage however is that the Rust process does not involve any manual text editing. What might sound trivial at first, is actually quite important for newcomers to the language. You do not have to know any syntax to get started with Rust since the generated code already compiles and does something interesting. In the other languages you have to write a valid, minimal program manually to even test the project setup while Rust is ready to go after just one command.

Of course this strategy is not without limitations. To be able to use \shinline{cargo} all files and directories have to follow a special pattern. Although the chosen conventions are somewhat common one cannot use arbitrary directory and file names.


\subsection{Comparison}
\label{subsec:Implementation::Setup::Comparison}

For newcomers Rust definitely provides the best experience. One can get a valid \textit{Hello world!} application without any prior knowledge which lowers the barrier of entry dramatically. In addition Rust does not require any presetup before the first project. just install the language toolchain (either through the operating system's package manager or the very simple setup script~\fnote{\url{https://static.rust-lang.org/rustup.sh}}) and start coding.

Go required some intial setup besides the installation but it still quite easy to setup. The \shinline{GOPATH} exporting is a small annoyance but it balances out with the benefits the developer get later down the line like dependency management. The syntax is very concise so creating a new source file with a \shinline{main} function is still quite fast.

Considering C's long lifespan the tooling for project setup is not very good. Full blown IDEs like Eclipse provide wizards to create all required files but for free standing development with a simple text editor and GNU \textit{make} there is no real automation possible. Naturally it is not hard to create an empty C source file however in this day and age it should not be necessary to manually have to adjust the order of linker flags in the \shinline{Makefile} because of obscure warnings in the compilation process.

This probably does not apply to seasoned C developers and one could make the argument that it is inherent to the language's ``closeness to the metal''. But acknowledging the fact that scientists more often than not see programming as an unwanted necessity to be able to complete their research it is questionable whether this technical know-how should really be required to use a language like C.

//TODO: maybe to wordy?

\section{Counting nodes, ways and relations in an .osm.pbf file}
\label{sec:Implementation::Counting}

\begin{table}[htb]
    \centering
    \begin{tabular}{llll}
        \toprule
        % Header
            & C
            & Go
            & Rust \\
        \midrule

        SLOC
            & 55
            & 55
            & 36 \\

        Development time (min)
            & 51:18
            & 21:16
            & 33:09 \\

        Execution time (sec)
            & 1,017 (-O0)
            & 4,846 (GOMAXPROCS=1)
            & 27,749 (-O0) \\
            & 0,994 (-O3)
            & 1,381 (GOMAXPROCS=8)
            & \hspace{6pt}2,722 (-O3) \\

        Allocation count
            & 2,390,566
            & 11,164,068\fnote{The memory statistics for Go have not been acquired by valgrind but by \shinline{runtime.MemStats} this and the fact that Go is garbage collected explain the discrepancy in allocations and frees}
            & 11,373,558 \\

        Free count
            & 2,390,566
            & 11,000,199\fnote{See footnote 3 //todo: verify footnote nr in final draft}
            & 11,373,557\fnote{This is due to a bug in the osmpbf library used. In safe Rust code it is impossible to leak memory} \\
        \bottomrule
    \end{tabular}
    \caption{Milestone 1: Counting nodes, ways and relations}
    \label{tb:milestone1}
\end{table}

\subsection{C}
\label{subsec:Implementation::Counting::C}


\subsection{Go}
\label{subsec:Implementation::Counting::Go}


\subsection{Rust}
\label{subsec:Implementation::Counting::Rust}


\subsection{Comparison}
\label{subsec:Implementation::Counting::Comparison}

\section{Building a basic graph representation for the simulation}
\label{sec:Implementation::Graph_Representation}

\begin{table}[htb]
    \centering
    \begin{tabular}{llll}
        \toprule
        % Header
            & C
            & Go
            & Rust \\
        \midrule

        SLOC (total)
            & 385
            & 196
            & 170 \\

        Development time (hours)
            & 02:30:32
            & 01:06:06
            & 01:14:28 \\
        \bottomrule
    \end{tabular}
    \caption{Milestone 2: Building a basic graph representation}
    \label{tb:milestone2}
\end{table}

\subsection{C}
\label{subsec:Implementation::Graph_Representation::C}


\subsection{Go}
\label{subsec:Implementation::Graph_Representation::Go}


\subsection{Rust}
\label{subsec:Implementation::Graph_Representation::Rust}


\subsection{Comparison}
\label{subsec:Implementation::Graph_Representation::Comparison}


\section{Verifying structure and algorithm}
\label{sec:Implementation::Verification}

\begin{table}[htb]
    \centering
    \begin{tabular}{llll}
        \toprule
        % Header
            & C
            & Go
            & Rust \\
        \midrule

        SLOC (total)
            & 637
            & 268
            & xxx \\

        Development time (hours)
            & 01:53:30
            & 01:16:49
            & xx:xx:xx \\

        Execution time (sec)
            & 0,004 (-O0)
            & 0,296
            & x,xxx (-O0) \\
            & 0,003 (-O3)
            & % itentionally blank since no parallel version was build
            & x,xxx (-O3) \\

        Allocation count
            & 108
            & 545\fnote{See footnote 3}
            & xxx \\

        Free count
            & 106\fnote{Due to the use of GLib some global state remains reachable after exiting. This is likely intended behaviour and not a memory leak. \\add link?}
            & 174\fnote{See footnote 3}
            & xxx \\
        \bottomrule
    \end{tabular}
    \caption{Milestone 3: Verifying the implementation}
    \label{tb:milestone3}
\end{table}

\subsection{C}
\label{subsec:Implementation::Verification::C}


\subsection{Go}
\label{subsec:Implementation::Verification::Go}


\subsection{Rust}
\label{subsec:Implementation::Verification::Rust}


\subsection{Comparison}
\label{subsec:Implementation::Verification::Comparison}
