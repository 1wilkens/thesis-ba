\chapter{Implementation}
\label{chap:Implementation}

\abstract{This chapter describes the implementation process for all three compared languages. It is divided in sections based on the development milestones defined in the previous chapter~\ref{sec:Approach::Implementation}.
}

\setcounter{section}{-1}
\section{Project setup}
\label{sec:Implementation::Setup}

As all applications written for this thesis have been developed on Linux the setup instructions are for this operating system. They \textbf{should} work on *nix as well but there is no definite guarantee this is the case. Also each section assumes the toolchains for the various languages are installed as this is largely different based on what operating system and on Linux which distribution is used. It is therefore not covered in this thesis.

\subsection{C}
\label{subsec:Implementation::Setup::C}

//TODO: Add footnotes/links

The buildtool for streets4C is GNU \textit{make} with a simple handcrafted \mdinline{Makefile}. It was chosen to strike a balance between full blown build systems like \textit{Autotools} or \textit{CMake} and manual compilation. The setup steps required for this configuration are relatively straight forward and listed below.
\\
\lstinputlisting[caption={Project setup: streets4C}, label={lst:setup_c.sh}, style=shell]{code/setup_c}

After creatig a new directory for the application a \mdinline{Makefile} and a sourcefile are created. \mdinline{main.c} contains just a bare bones main method while the \mdinline{Makefile} uses basic rules to compile an executable named streets4c with various optimization flags.

All in all the setup in C is quite painless although manual. The only caveat are Makefiles. They may be simple for small projects without real dependencies but as soon as different source and object files are involved in the compilation process they can get quite confusing. At that point the mentioned build systems might prove their worth in generating the Makefile(s).


\subsection{Go}
\label{subsec:Implementation::Setup::Go}

//TODO: Add footnotes/links

For Go the choice of buildtool is nonexistent. The language provides the \mdinline{go} executable which is responsible for nearly the complete development cycle. It can compile your code, install arbitary Go packages from various sources, run tests and format code just to name the most common features.

This makes Go (the language) extremly convenient since everything you want to do is probably one commandline away. For example to get a depdendency one would invoke the tool like so:
\mdinline{go get github.com/petar/GoLLRB/llrb}
\\
This will download the package in source form which can then be imported in any project on that machine via its fully qualified package name.

To achieve this convenience the \mdinline{go} tool requires some setup work before it can be used for the first time. Because of this this section contains two setup examples.
\\
\lstinputlisting[caption={Project setup: streets4Go}, label={lst:setup_go.sh}, style=shell]{code/setup_go}

Listing \ref{lst:setup_go.sh} describes the steps that were taken to create the streets4go project inside the thesis' repository. It is pretty similiar to the C version. A directory gets creates then a source file containing a \mdinline{main} function is created which can be build and run with a single command.

One thing to remind here is the fact, that this code does not live inside a globally set drectory called GOPATH. To be able to download packages only once \mdinline{go} assumes an environment variable called GOPATH to be set to a directory which it has full control over. This directory contains all source files as well a the compiled binaries all stored through a consistent naming scheme. Normally it is assumed that all Go project live inside their own subdirectories of the GOPATH but it is possible to avoid this at the cost of some convenience.

The project that was created through the commands of listing \ref{lst:setup_go.sh} for example cannot be installed to the system by running \mdinline{go install} since it does not reside in the correct folder instead one has to copy the compiled binary to a directory in PATH manually.

The next listing shows a more realistic workflow for creating a new Go project from scratch without any prior setup required. It assumes one starts in the directory that should be set as GOPATH and assumes \url{www.github.com} as code host which in reality just determines the package name.
\\
\lstinputlisting[caption={Full setup for new Go projects}, label={lst:setup_go_full.sh}, style=shell]{code/setup_go_full}


\subsection{Rust}
\label{subsec:Implementation::Setup::Rust}

//TODO: Add footnotes/links
Lorem ipsum
\\
\lstinputlisting[caption={Project setup: streets4Rust}, label={lst:setup_rust.sh}, style=shell]{code/setup_rust}


\subsection{Comparison}
\label{subsec:Implementation::Setup::Comparison}

\section{Counting nodes, ways and relations in an .osm.pbf file}
\label{sec:Implementation::Counting}

\begin{table}[htb]
    \centering
    \begin{tabular}{llll}
        \toprule
        % Header
            & C
            & Go
            & Rust \\
        \midrule

        SLOC
            & 55
            & 55
            & 36 \\

        Development time (min)
            & 51:18
            & 21:16
            & 33:09 \\

        Execution time (sec)
            & 1,017 (-O0)
            & 4,846 (GOMAXPROCS=1)
            & 27,749 (-O0) \\
            & 0,994 (-O3)
            & 1,381 (GOMAXPROCS=8)
            & \hspace{6pt}2,722 (-O3) \\

        Allocation count
            & 2,390,566
            & 11,164,068\fnote{The memory statistics for Go have not been acquired by valgrind but by \mdinline{runtime.MemStats} this and the fact that Go is garbage collected explain the discrepancy in allocations and frees}
            & 11,373,558 \\

        Free count
            & 2,390,566
            & 11,000,199\fnote{See footnote 1}
            & 11,373,557\fnote{This is due to a bug in the osmpbf library used. In safe Rust code it is impossible to leak memory} \\
        \bottomrule
    \end{tabular}
    \caption{Milestone 1: Counting nodes, ways and relations}
    \label{tb:milestone1}
\end{table}

\section{Building a basic graph representation for the simulation}
\label{sec:Implementation::Graph_Representation}

\begin{table}[htb]
    \centering
    \begin{tabular}{llll}
        \toprule
        % Header
            & C
            & Go
            & Rust \\
        \midrule

        SLOC
            & 385
            & 196
            & 170 \\

        Development time (hours)
            & 02:30:32
            & 01:06:06
            & 01:14:28 \\
        \bottomrule
    \end{tabular}
    \caption{Milestone 2: Building a basic graph representation}
    \label{tb:milestone2}
\end{table}

\begin{verbatim}
Milestones:
- Count all nodes, ways and relations in hamburg-latest.osm.pbf
    - Rust:
        - SLOC: 36
        - dev-time: 1989 -> 33:09 min
        - run-time:
            - -O0: target/streets4rust ../osm/hamburg-latest.osm.pbf  27,61s user 0,12s system 99\% cpu 27,749 total
            - -O3: target/release/streets4rust ../osm/hamburg-latest.osm.pbf  2,59s user 0,13s system 99\% cpu 2,722 total
        - allocs: total heap usage: 11,373,558 allocs, 11,373,557 frees, 2,186,107,072 bytes allocated
        - counts: Found 2180418 nodes, 409424 ways and 7182 relations in ../osm/hamburg-latest.osm.pbf
        - notes:
            - easy dependency management, huuge optimization gains
    - Go:
        - SLOC: 55 (+ helper functions)
        - dev-time: 1276 -> 21:16 min
        - run-time:
            - GOMAXPROCS=1: ./streets4go ../osm/hamburg-latest.osm.pbf  4,85s user 0,05s system 101\% cpu 4,846 total
            - GOMAXPROCS=8: ./streets4go ../osm/hamburg-latest.osm.pbf  9,00s user 0,28s system 672\% cpu 1,381 total
        - allocs: total heap usage: 11,164,068 allocs, 11,000,199 frees, 1,447,543,184 bytes allocated
        - counts: Found 2180418 nodes, 409424 ways and 7182 relations in ../osm/hamburg-latest.osm.pbf
        - notes:
            - library parallelizeable, but singlethreaded slower
    - C:
        - SLOC: 55
        - dev-time: 3078 -> 51:18 min
        - run-time:
            - -O0: ./streets4c ../osm/hamburg-latest.osm.pbf  0,95s user 0,07s system 99\% cpu 1,017 total
            - -O3: ./streets4c ../osm/hamburg-latest.osm.pbf  0,92s user 0,08s system 99\% cpu 0,994 total
        - allocs: total heap usage: 2,390,566 allocs, 2,390,566 frees, 372,758,206 bytes allocated
        - counts: Found 2180418 nodes, 409424 ways and 7182 relations in ../osm/hamburg-latest.osm.pbf
        - notes:
            - no library available, linking problems, freeing problems, fastest solution (run), slowest solution (dev)
- Write basic graph structure
    - C:
        - SLOC: 385 (*.c), 136 (*.h) -> 521 total
        - dev-time: 12110 - 3078 = 9032 -> 02:30:32
        - notes:
            - glib verbosity, missing generics / typesafety
    - Rust:
        - SLOC: 170 total
        - dev-time: 6457 - 1989 = 4468 -> 01:14:28
        - notes:
            - lifetime gotchas (explicit readonly of dg.g etc.)
    - Go:
        - SLOC: 196 total (including util (priorityqueue) but excluding test)
        - dev-time: 5242 - 1276 = 3966 -> 01:06:06
        - notes:
            - testability
\end{verbatim}
