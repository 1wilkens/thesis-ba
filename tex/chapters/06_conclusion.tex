\chapter{Conclusion}
\label{ch:Conclusion}

\abstract{In this final chapter a short summary is given and the thesis concludes with a brief description of possible improvements and future work.}

\section{Summary}
\label{sec:Conclusion::Summary}

\section{Improvements and future work}
\label{sec:Conclusion::Improvements}

Although this evaluation already yielded some interesting results regarding new programming languages in \gls{hpc} there are still lots of potential research topics in this area. Also there are some missed opportunities for a more complete result which were just not considered or skipped due to time constraints. This section addresses both of these areas and concludes this thesis.

\subsection*{General code quality}
\label{subsec:Conclusion::Improvements::CodeQuality}

As mentioned a few times in the thesis the quality of the implementations might not be optimal especially in the case \textit{streets4C}. This can mostly be attributed to the author's lack of equal experience in the three evaluated languages. While this is to a point intentional, as scientists might not be proficient in these languages either the implementations could be reviewed by language experts to really demonstrate the absolute highest possible performance.

\subsection*{Limited benchmark configurations}
\label{subsec:Conclusion::Improvements::Configuration}

Although the benchmark results presented in the previous chapter allow for some decent conclusions the configurations could have been extended. Especially the problem size which was fixed at 100K nodes could have been varied for multiple thread amounts. Another possible comparison could include different compilers for C and Go (Rust currently only has one reference implementation) or multiple compiler and library versions revealing possible regressions across versions.

\subsection*{Limitation to shared memory}
\label{subsec:Conclusion::Improvements::SharedMemory}

While thread based concurrency is certainly an important aspect in \gls{hpc} the dominant model is distributed memory communicating via message passing. This technique was not evaluated in this thesis because of missing library support but the general performance of the languages should still be applicable. As both Rust and Go have good capabilities to link to native C libraries it might be possible to use a standard \gls{mpi} implementation today. A complete library written in the target language should be preferred whenever available though because interfacing with C often restricts the types which can be used. When these libraries have matured enough (if ever) it might be very valuable to reassess the candidates in the \gls{hpc} context.
