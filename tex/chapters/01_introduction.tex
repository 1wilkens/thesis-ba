\chapter{Introduction}
\label{ch:Introduction}

\abstract{This chapter provides some background information to \gls{hpc}. The first section describes problems with the currently used programming languages and motivates the search for new candidates. After that the chapter concludes with a quick rundown of the thesis' goals.
}

\section{Motivation}
\label{sec:Introduction::Motivation}

The world of \gls{hpc} is evolving rapidly and programming languages used in this environment are held up to a very high standard. It comes as no surprise that runtime performance is the top priority in language selection when an hour of computation costs thousands of dollars~\cite{cost_of_science}. The focus on raw power led to C and Fortran having an almost monopolistic position in the field, because their execution speed is nearly unmatched.

However programming in these rather antique languages can be rather difficult. Although they are still in active development, their long lifespans resulted in sometimes unintuitive syntax and large amounts of historical debt. Especially C's \textit{undefined behaviour} often causes inexperienced programmers to write unreliable code which is unnecessarily dependent on implementation details of a specific compiler or the underlying machine. Understanding and maintaining these programs requires deep knowledge of memory layout and other technical details. In contrast Fortran does not require the same amount of technical knowledge but also limits the programmer in fine grained resource control. Both approaches are not ideal and the situation could be improved by a language offering both control and high-level abstractions while keeping up with Fortran and C's execution performance.

Also considering the fact that scientific applications are often written by scientist without a strong background in computer science it is evident that the current situation is less than ideal. There have been various efforts to make programming languages more accessible in the recent years but unfortunately none of the newly emerged ones have been successful in establishing themselves in the \gls{hpc} community to this day. Although many features and concepts have found their way in newer revision of C and Fortran standards most of them feel tacked on and are not well integrated into the core language.

One example for this is the common practice of testing. Specifically with the growing popularity of \textit{\gls{tdd}} it became vital to the development process to be able to quickly and regularly execute a set of tests to verfiy growing implementations as they are developed. Of course there are also testing frameworks and libraries for Fortran and C but since these languages lack deep integration of testing concepts, they often require a lot of setup and boilerplate code and are generally not that pleasant to work with. In contrast, for example, the Go programming language includes a complete testing framework with the ability to perform benchmarks, perform global setup/teardown work and even do basic output verification~\cite{go_doc_testing}. Most importantly all this is available via a single executable \mdinline{go test} which may be easily integrated in scripts or other parts of the workflow.

While testing is just one example there are a lot of ``best practices'' and techniques which can greatly increase both developer productivity and code quality but require a language-level integration to work best. Combined with the advancements in type system theory and compiler construction both C and Fortran's feature sets look very dated. With this in mind it is time to review new potential successors of the two giants of \gls{hpc}.

\section{Goals of this thesis}
\label{sec:Introduction::Goals}

This thesis aims to evaluate Rust and Go as potential programming languages in the \gls{hpc} environment. The comparison is based on three implementations of a shortest path algorithm in the two language candidates as well as C. The idea is based on an existing parallel application called \textit{streets4MPI} which was written in Python. It simulates ongoing traffic in a geographical area creating heatmaps as a result. The programs written for this thesis implement the computational intensive part which is the shortest path calculation to be able to review Go and Rust's performance characteristics as well as development productivity and tooling support. Since libraries for interprocess communication in Rust and Go are nowhere near production-ready this thesis will focus on shared memory parallelization only to avoid unfair bias based solely on the quality of the supporting library ecosystem.

To reduce complexity the implementations perform no real error handling nor produce any usable simulation output. They simply perform Dijkstra's algorithm in the most language ideomatic way which can optionally be parallelized. While raw performance will be the main criteria, additional productivity metrics will also be reviewed to rate the general development experience. Another focus will be the barrier of entry for newcomers to the respective languages which is important for scientiest less proficient in programming.
